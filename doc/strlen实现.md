以下是使用 RISC-V RV32G 汇编实现的 `strlen` 函数：

```assembly
# strlen 函数：计算以空字符结尾的字符串长度
# 输入：a0 - 字符串起始地址
# 输出：a0 - 字符串长度（不含空字符）
strlen:
    mv    t0, a0       # 保存起始地址到 t0
loop:
    lb    t1, 0(a0)    # 加载当前字符到 t1
    beqz  t1, end      # 若字符为 0，结束循环
    addi  a0, a0, 1    # 指针递增
    j     loop         # 继续循环
end:
    sub   a0, a0, t0   # 计算长度（当前地址 - 起始地址）
    ret                # 返回结果
```

### 代码解析：
1. **保存起始地址**：  
   使用 `mv t0, a0` 将输入的字符串起始地址保存到临时寄存器 `t0`。`mv` 是伪指令，实际转换为 `addi t0, a0, 0`。

2. **循环遍历字符**：  
   - `lb t1, 0(a0)`：从 `a0` 指向的地址加载一个字节到 `t1`。  
   - `beqz t1, end`：若 `t1` 为 0（字符串结束符），跳转到 `end` 标签结束循环。  
   - `addi a0, a0, 1`：递增指针 `a0` 以检查下一个字符。  
   - `j loop`：无条件跳转回循环开始。

3. **计算长度并返回**：  
   - `sub a0, a0, t0`：将当前地址 `a0`（指向空字符）减去起始地址 `t0`，得到字符串长度。  
   - `ret`：将结果保存在 `a0` 中返回。

### 注意事项：
- **对齐问题**：逐字节访问避免了内存对齐问题，确保安全性。
- **效率**：此实现逐字节检查，简单可靠。对于长字符串，可通过字（4 字节）读取优化性能，但需处理对齐和掩码操作，复杂度较高。
- **调用约定**：符合 RISC-V 规范，参数通过 `a0` 传递，结果通过 `a0` 返回，临时寄存器 (`t0`, `t1`) 无需保存。