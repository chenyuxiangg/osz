# 说明

Bxxx: Bug id
Dxxx: 设计改进点id
Qxxx: 待解决的问题（非bug）id

## 2025.11.8

1. [B001]`osz_msleep` 函数延时不准问题，比如 `osz_msleep(20)` 并不是真正的延时20ms;
2. [B002]任务运行结束return时无法正确处理逻辑，比如任务体return时，会进入到`inner_task_exit`函数，该函数处理完逻辑后是否应该调度？

> a. `inner_task_exit`中会调用`osz_task_delete`，该函数中会调度

## 2025.11.9

3. [B003]任务无法销毁

> a. 原因是传入`inner_task_exit`的参数(task_id)不正确，修改为获取当前任务的task_id -- 2025.11.12

5. 吐槽一下：AI写的ST是真的拉胯，还是得自己动手呀...

## 2025.11.12

6. [D001]任务栈应该设计为“自动申请”或者“用户手动传入”;
7. [D002]所有异常分支（直接return的地方）都应该增加调试手段，比如打印；

## 2025.11.13

8. [B004]带延时的`osz_sem_pend`函数处理有异常，函数状态会被置为0xc，且无法被加入就绪队列；

> a. 原因是待延时的`osz_sem_pend`函数既会将任务挂载到sem的pending列表，也会将任务挂载到sortlink的block列表。当超时唤醒时，由于pending链表和ready链表共用同一个结构体（互斥），且pending链表已经被挂载到sem上，所以无法将ready链表加入就绪队列，导致任务状态虽然被置为ready，但是无法被调度。-- 2025.11.14
> b. 该bug并未完全解决，当时仅考虑到超时后通过定时器唤醒的场景，并没有考虑`osz_sem_post`优先唤醒任务的场景，因此解决该问题的方法应该是将任务的状态置位为`TSK_FLAG_PENDING` | `TSK_FLAG_BLOCKING`。 -- 2025.11.15

## 2025.11.15
9. [B005]在osz_task_wake函数中增加一行printf打印后出现死机，问题所指的mepc为0；
    
> a. 原因是printf需要占用1024B的栈空间，当任务栈过小时，会导致越界飞踩，通过增大任务栈空间解决该问题；-- 2025.11.15

10.  [Q001]任务栈越界如何检测？场景：顺序越界踩 | 飞踩（比如使用prinf）